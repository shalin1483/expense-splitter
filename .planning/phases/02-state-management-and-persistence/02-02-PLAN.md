---
phase: 02-state-management-and-persistence
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/stores/historyStore.ts
  - src/stores/historyStore.test.ts
  - src/stores/integration.test.ts
autonomous: true

must_haves:
  truths:
    - "Multiple completed bills can be saved to history"
    - "Saved bills can be retrieved and viewed from history"
    - "Bill history persists across browser refresh"
    - "History is limited to prevent localStorage quota issues"
    - "State changes trigger recalculation of derived totals"
  artifacts:
    - path: "src/stores/historyStore.ts"
      provides: "Zustand history store with persist middleware for saved bills"
      exports: ["useHistoryStore", "useSavedBills", "useHistoryActions"]
    - path: "src/stores/historyStore.test.ts"
      provides: "Tests for history store save, delete, clear, and limit behavior"
      min_lines: 50
    - path: "src/stores/integration.test.ts"
      provides: "Integration tests verifying persistence, recalculation, and cross-store workflows"
      min_lines: 60
  key_links:
    - from: "src/stores/historyStore.ts"
      to: "src/lib/types/bill.ts"
      via: "Uses Person, Item, Assignment types for saved bill structure"
      pattern: "import.*from.*bill"
    - from: "src/stores/historyStore.ts"
      to: "src/stores/schemas.ts"
      via: "Validates saved bills on rehydration"
      pattern: "safeParse"
    - from: "src/stores/integration.test.ts"
      to: "src/stores/billStore.ts"
      via: "Tests bill store actions trigger recalculation"
      pattern: "useBillStore"
    - from: "src/stores/integration.test.ts"
      to: "src/lib/calculations/tax.ts"
      via: "Verifies tax distribution integrates with store state"
      pattern: "calculateTax|distributeTax"
---

<objective>
Create the history store for saving/retrieving completed bills and write integration tests verifying persistence, validation, and recalculation across the full state layer.

Purpose: History store enables the "save split for reference" feature. Integration tests prove the stores work together with Phase 1 calculation functions - the critical wiring between state management and the calculation engine.

Output: Working history store that can save, retrieve, and delete past bills. Integration tests proving end-to-end state management with persistence and recalculation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-state-management-and-persistence/02-RESEARCH.md
@.planning/phases/02-state-management-and-persistence/02-01-SUMMARY.md
@src/lib/types/bill.ts
@src/stores/schemas.ts
@src/stores/billStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create history store with persist middleware and tests</name>
  <files>
    src/stores/historyStore.ts
    src/stores/historyStore.test.ts
  </files>
  <action>
1. Create `src/stores/historyStore.ts`:

   **SavedBill type** (define in this file or add to bill.ts):
   ```
   interface SavedBill {
     id: string;
     timestamp: number;           // Date.now() when saved
     label?: string;              // Optional user label (e.g., "Dinner at Luigi's")
     people: Person[];
     items: Item[];
     assignments: Record<string, Assignment>;
     taxInput: TaxInput | null;
     tipRate: number;
     totalInCents: Cents;         // Cached total for display in history list
   }
   ```

   **HistoryState interface:**
   - `bills: SavedBill[]` (most recent first)
   - `actions` object containing:
     - `saveBill(bill: Omit<SavedBill, 'id' | 'timestamp'>, label?: string)`: Prepend new saved bill with crypto.randomUUID() id and Date.now() timestamp. Slice to keep only last 50 bills to prevent localStorage quota issues.
     - `deleteBill(id: string)`: Remove bill by id
     - `clearHistory()`: Empty the bills array
     - `getBillById(id: string)`: Return bill or undefined (non-reactive, use getState pattern)

   **Persist middleware configuration:**
   - localStorage key: `'expense-splitter-history'`
   - `partialize`: Persist bills only (exclude actions)
   - `version: 1`
   - `migrate`: Validate with z.array(SavedBillSchema) where SavedBillSchema extends BillDataSchema with id, timestamp, label, totalInCents fields. On failure, reset to empty array.

   **Selector hooks:**
   - `useSavedBills()`: Select bills array
   - `useHistoryActions()`: Select actions object

   Also export `useHistoryStore` for testing and advanced use.

   Add `SavedBillSchema` to `src/stores/schemas.ts` (or define inline - prefer schemas.ts for consistency). If modifying schemas.ts, add it as a file in this task. The schema should extend BillDataSchema with: id (z.string()), timestamp (z.number()), label (z.string().optional()), totalInCents (z.number().int().nonnegative()).

2. Create `src/stores/historyStore.test.ts`:

   **Test setup:** Reset store state between tests. Mock or clear localStorage.

   **Test cases:**
   - saveBill adds bill with generated id and timestamp
   - saveBill prepends (newest first)
   - saveBill limits to 50 bills (add 51, verify length is 50, oldest removed)
   - saveBill includes optional label when provided
   - deleteBill removes specific bill by id
   - deleteBill with nonexistent id is no-op
   - clearHistory empties bills array
   - getBillById returns correct bill
   - getBillById returns undefined for nonexistent id
   - Invalid persisted state resets to empty array
  </action>
  <verify>
  Run `npm test` - all tests pass including new history store tests plus existing tests from Phase 1 and Plan 02-01.
  </verify>
  <done>
  History store saves, retrieves, and deletes past bills. Bills persist to localStorage under 'expense-splitter-history' key. History limited to 50 entries. Zod validation protects against corruption. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for persistence, recalculation, and cross-store workflows</name>
  <files>
    src/stores/integration.test.ts
  </files>
  <action>
Create `src/stores/integration.test.ts` with end-to-end tests verifying the state layer works correctly with Phase 1 calculation functions. These tests prove the critical wiring between stores and calculations.

**Test groups:**

1. **Recalculation from state** (Phase 2 Success Criterion #2):
   - Add 3 people and 2 items to bill store, assign items to people
   - Use Phase 1 functions (splitEqually, allocateProportionally) on store state to compute per-person subtotals
   - Set tax input (rate-based), calculate tax with calculateTax, distribute with distributeTax
   - Set tip rate, calculate tip with calculateTip, distribute with distributeTip
   - Verify final totals (subtotal + tax share + tip share) for each person sum to grand total
   - Verify all amounts are integer cents (no floating point)

2. **Persistence round-trip** (Phase 2 Success Criterion #1):
   - Add people and items to bill store via actions
   - Read store state, verify it contains correct data
   - Simulate persistence by: get state -> JSON.stringify -> JSON.parse -> validate with BillDataSchema
   - Verify parsed state matches original (demonstrates localStorage would preserve data correctly)

3. **Cascading cleanup**:
   - Add 2 people, 2 items, assign items to both people
   - Remove person 1 -> verify assignments updated (person 1 removed from personIds)
   - Remove item 1 -> verify its assignment deleted
   - Verify remaining data is internally consistent

4. **Save bill to history workflow**:
   - Build a complete bill in billStore (people, items, assignments, tax, tip)
   - Calculate total using Phase 1 functions
   - Save snapshot to historyStore via saveBill action
   - Reset billStore
   - Verify billStore is empty
   - Verify historyStore has the saved bill with correct data

5. **Validation edge cases** (Phase 2 Success Criterion #4):
   - Attempt to add person with empty name -> verify no-op
   - Attempt to add item with negative price -> verify no-op
   - Set tip rate above 1.0 -> verify clamped to 1.0
   - Set tip rate below 0 -> verify clamped to 0

**Import Phase 1 functions directly:**
```typescript
import { splitEqually } from '@/lib/calculations/split';
import { allocateProportionally } from '@/lib/calculations/allocate';
import { calculateTax, distributeTax } from '@/lib/calculations/tax';
import { calculateTip, distributeTip } from '@/lib/calculations/tip';
import { toCents } from '@/lib/types/money';
```

These tests verify the integration layer - that Phase 2 state management correctly feeds into Phase 1 calculation functions and produces correct results.
  </action>
  <verify>
  Run `npm test` - all tests pass. Total test count should be 53 (Phase 1) + billStore tests (from 02-01) + historyStore tests + integration tests. Run `npx tsc --noEmit` to verify full type safety across the integrated codebase.
  </verify>
  <done>
  Integration tests prove: (1) Store state feeds correctly into calculation functions producing accurate per-person totals. (2) State round-trips through JSON serialization without data loss. (3) Cascading cleanup maintains data consistency. (4) Bill-to-history save workflow works end-to-end. (5) Input validation prevents invalid configurations. All Phase 2 success criteria are verifiable through automated tests.
  </done>
</task>

</tasks>

<verification>
1. `npm test` passes with 0 failures across ALL test files (Phase 1 + Phase 2)
2. `npx tsc --noEmit` compiles with 0 errors
3. History store persists under separate localStorage key ('expense-splitter-history')
4. Integration tests demonstrate recalculation: state changes -> Phase 1 functions -> correct totals
5. Integration tests demonstrate persistence: state -> JSON -> validate -> identical state
6. Integration tests demonstrate validation: invalid inputs rejected or clamped
</verification>

<success_criteria>
- History store can save, retrieve, and delete past bills
- History limited to 50 entries to prevent localStorage quota issues
- Integration tests verify store state flows correctly through Phase 1 calculation functions
- State persists across simulated browser refresh (JSON round-trip)
- Cascading cleanup maintains referential integrity
- All Phase 2 success criteria have corresponding passing tests
- Total test suite passes with zero failures
</success_criteria>

<output>
After completion, create `.planning/phases/02-state-management-and-persistence/02-02-SUMMARY.md`
</output>
