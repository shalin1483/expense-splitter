---
phase: 02-state-management-and-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/types/bill.ts
  - src/stores/schemas.ts
  - src/stores/billStore.ts
  - src/stores/billStore.test.ts
autonomous: true

must_haves:
  truths:
    - "Bill state (people, items, assignments) can be created and modified through store actions"
    - "Bill state persists to localStorage automatically on every change"
    - "State rehydrates from localStorage on store initialization"
    - "State validation rejects invalid data and resets to defaults"
    - "Selector hooks provide atomic access to individual state slices"
  artifacts:
    - path: "src/lib/types/bill.ts"
      provides: "Person, Item, Assignment, BillData domain types"
      exports: ["Person", "Item", "Assignment", "CustomSplit", "BillData"]
    - path: "src/stores/schemas.ts"
      provides: "Zod validation schemas for all bill domain types"
      exports: ["PersonSchema", "ItemSchema", "AssignmentSchema", "BillDataSchema"]
    - path: "src/stores/billStore.ts"
      provides: "Zustand bill store with persist middleware and selector hooks"
      exports: ["useBillStore", "usePeople", "useItems", "useAssignments", "useBillActions", "useTaxInput", "useTipRate"]
    - path: "src/stores/billStore.test.ts"
      provides: "Tests for bill store actions, validation, and persistence"
      min_lines: 80
  key_links:
    - from: "src/stores/schemas.ts"
      to: "src/lib/types/bill.ts"
      via: "Zod schemas validate bill domain types"
      pattern: "z\\.object"
    - from: "src/stores/billStore.ts"
      to: "src/stores/schemas.ts"
      via: "migrate function validates persisted state"
      pattern: "BillDataSchema\\.safeParse"
    - from: "src/stores/billStore.ts"
      to: "src/lib/types/money.ts"
      via: "Uses Cents type for all money values"
      pattern: "import.*Cents.*from"
---

<objective>
Install Zustand and Zod, define bill domain types, create Zod validation schemas, and build the core bill store with persist middleware and atomic selector hooks.

Purpose: This is the foundational state layer. Every future UI component will read from and write to this store. The persist middleware ensures bill data survives browser refresh. Zod schemas protect against corrupted localStorage data.

Output: Working bill store that can add/remove people, add/remove items, manage assignments, set tax/tip, and auto-persist all changes to localStorage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-state-management-and-persistence/02-RESEARCH.md
@src/lib/types/money.ts
@src/lib/calculations/split.ts
@src/lib/calculations/allocate.ts
@src/lib/calculations/tax.ts
@src/lib/calculations/tip.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create bill domain types with Zod schemas</name>
  <files>
    package.json
    src/lib/types/bill.ts
    src/stores/schemas.ts
  </files>
  <action>
1. Install Zustand and Zod:
   ```
   npm install zustand zod
   ```

2. Create `src/lib/types/bill.ts` with domain types that model the bill-splitting workflow. All money values use `Cents` from `@/lib/types/money`. Types needed:

   - `Person`: `{ id: string; name: string }` - a person at the table
   - `Item`: `{ id: string; name: string; priceInCents: Cents }` - a line item from the receipt
   - `CustomSplit`: `{ personId: string; amountInCents: Cents }[]` - custom split amounts for a shared item
   - `Assignment`: `{ itemId: string; personIds: string[]; customSplit?: CustomSplit }` - which people share an item, with optional custom split override (requirement ITEM-04)
   - `TaxInput` re-export from `@/lib/calculations/tax` (already defined there as union type)
   - `BillData`: `{ people: Person[]; items: Item[]; assignments: Record<string, Assignment>; taxInput: TaxInput | null; tipRate: number }` - the complete bill state that gets persisted. Use `Record<string, Assignment>` keyed by itemId for O(1) lookup.

   Export all types. Import `Cents` from `@/lib/types/money` and `TaxInput` from `@/lib/calculations/tax`.

3. Create `src/stores/schemas.ts` with Zod schemas mirroring each domain type:

   - `PersonSchema`: z.object with id (z.string()), name (z.string().min(1))
   - `ItemSchema`: z.object with id (z.string()), name (z.string().min(1)), priceInCents (z.number().int().nonnegative())
   - `CustomSplitEntrySchema`: z.object with personId (z.string()), amountInCents (z.number().int().nonnegative())
   - `AssignmentSchema`: z.object with itemId (z.string()), personIds (z.array(z.string())), customSplit (z.array(CustomSplitEntrySchema).optional())
   - `TaxInputSchema`: z.discriminatedUnion on "type" field - rate variant (type: z.literal('rate'), rate: z.number().min(0).max(1)) or exact variant (type: z.literal('exact'), amount: z.number().int().nonnegative())
   - `BillDataSchema`: z.object combining people (z.array(PersonSchema)), items (z.array(ItemSchema)), assignments (z.record(AssignmentSchema)), taxInput (TaxInputSchema.nullable()), tipRate (z.number().min(0).max(1))

   Export all schemas.

   NOTE: Use Zod 4 import syntax: `import { z } from 'zod'`. Zod 4 API is mostly compatible with Zod 3 for these basic schemas. Check if z.discriminatedUnion is available in Zod 4 - if not, use z.union instead.
  </action>
  <verify>
  Run `npm test` to confirm existing 53 tests still pass (no regressions from dependency install). Manually verify `src/lib/types/bill.ts` and `src/stores/schemas.ts` compile with `npx tsc --noEmit`.
  </verify>
  <done>
  Zustand and Zod installed in package.json. Bill domain types defined and exported from `src/lib/types/bill.ts`. Zod validation schemas defined and exported from `src/stores/schemas.ts`. All existing tests pass. TypeScript compiles with no errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create bill store with persist middleware, selector hooks, and tests</name>
  <files>
    src/stores/billStore.ts
    src/stores/billStore.test.ts
  </files>
  <action>
1. Create `src/stores/billStore.ts` implementing the Zustand store with persist middleware:

   **State shape** (BillState interface):
   - `people: Person[]`
   - `items: Item[]`
   - `assignments: Record<string, Assignment>` (keyed by itemId)
   - `taxInput: TaxInput | null` (null = no tax configured yet)
   - `tipRate: number` (decimal, e.g. 0.18 = 18%, default 0.18)
   - `actions` object containing all mutation methods (grouped under `actions` key so they don't trigger re-renders when selected)

   **Actions** (all inside `actions` object):
   - `addPerson(name: string)`: Append new Person with `crypto.randomUUID()` id. Validate name is non-empty string (trim whitespace). If empty after trim, do nothing (no-op, don't throw).
   - `removePerson(id: string)`: Remove person from people array. Also clean up assignments: remove person from all assignment personIds arrays. If an assignment's personIds becomes empty, delete that assignment entry.
   - `addItem(name: string, priceInCents: Cents)`: Append new Item. Validate name non-empty and priceInCents >= 0 (no-op if invalid).
   - `removeItem(id: string)`: Remove item from items array and delete its assignment from assignments record.
   - `assignItem(itemId: string, personIds: string[])`: Set assignment for itemId. Create Assignment object `{ itemId, personIds }`. If personIds is empty, delete the assignment instead.
   - `setCustomSplit(itemId: string, customSplit: CustomSplit)`: Update the assignment for itemId to include customSplit. Only works if assignment already exists.
   - `clearCustomSplit(itemId: string)`: Remove customSplit from the assignment for itemId (revert to equal split).
   - `setTaxInput(input: TaxInput | null)`: Set the tax configuration. Pass null to clear.
   - `setTipRate(rate: number)`: Set tip rate. Clamp to 0-1 range.
   - `reset()`: Reset all state to initial values: empty people, items, assignments, null taxInput, 0.18 tipRate.

   **Persist middleware configuration:**
   - localStorage key: `'expense-splitter-bill'`
   - `partialize`: Only persist people, items, assignments, taxInput, tipRate (exclude actions)
   - `version: 1` for future migration support
   - `migrate` function: Use `BillDataSchema.safeParse(persistedState)`. If validation fails, log warning and return initial state (empty arrays, null tax, 0.18 tip). If success, return parsed data.
   - `onRehydrateStorage`: Log errors if hydration fails

   **Selector hooks** (export individually, NOT the raw store):
   - `usePeople()`: Select people array
   - `useItems()`: Select items array
   - `useAssignments()`: Select assignments record
   - `useTaxInput()`: Select taxInput
   - `useTipRate()`: Select tipRate
   - `useBillActions()`: Select actions object (stable reference, never triggers re-render)

   Also export `useBillStore` for advanced use cases and testing.

   Import types from `@/lib/types/bill`. Import schemas from `@/stores/schemas` (use relative path `./schemas` since stores are siblings). Use `crypto.randomUUID()` for IDs (available in Node 19+ and all modern browsers).

2. Create `src/stores/billStore.test.ts` with comprehensive tests:

   **Test setup:** Since Zustand persist uses localStorage, mock it or use a test helper. Zustand stores in tests should use `useBillStore.getState()` and `useBillStore.setState()` directly (no React rendering needed for state-only tests). Reset store state between tests using `beforeEach`.

   **Test cases to cover:**

   People management:
   - addPerson creates person with UUID and trimmed name
   - addPerson with empty/whitespace-only name is no-op
   - removePerson removes the person
   - removePerson cleans up assignments referencing that person
   - removePerson deletes assignment when last person removed from it

   Item management:
   - addItem creates item with UUID, name, and priceInCents
   - addItem with invalid price (negative) is no-op
   - removeItem removes item and its assignment

   Assignment management:
   - assignItem creates assignment with itemId and personIds
   - assignItem with empty personIds deletes assignment
   - setCustomSplit adds custom split to existing assignment
   - clearCustomSplit removes custom split from assignment

   Tax and tip:
   - setTaxInput sets rate-based tax
   - setTaxInput sets exact tax
   - setTaxInput(null) clears tax
   - setTipRate sets rate and clamps to 0-1

   Reset:
   - reset clears all state to defaults

   Validation:
   - Invalid persisted state triggers migration to defaults (test by setting invalid data in store state, checking schema validation behavior)

   **Important:** For Vitest + Zustand testing, you may need to reset the store between tests. Use `useBillStore.setState(initialState)` in `beforeEach`. The persist middleware may interfere with tests - consider mocking localStorage or using `useBillStore.persist.clearStorage()` between tests.
  </action>
  <verify>
  Run `npm test` - all tests pass including new billStore tests plus existing 53 calculation tests. Run `npx tsc --noEmit` - TypeScript compiles with no errors.
  </verify>
  <done>
  Bill store created with all CRUD actions for people, items, assignments, tax, and tip. Persist middleware auto-saves to localStorage. Zod validation protects against corrupted state on rehydration. Atomic selector hooks exported. All tests pass. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npm test` passes with 0 failures (existing 53 tests + new billStore tests)
2. `npx tsc --noEmit` compiles with 0 errors
3. `src/stores/billStore.ts` exports: useBillStore, usePeople, useItems, useAssignments, useBillActions, useTaxInput, useTipRate
4. `src/stores/schemas.ts` exports: PersonSchema, ItemSchema, AssignmentSchema, BillDataSchema, TaxInputSchema
5. `src/lib/types/bill.ts` exports: Person, Item, Assignment, CustomSplit, BillData
6. Persist middleware configured with key 'expense-splitter-bill' and version 1
</verification>

<success_criteria>
- People can be added/removed via store actions; assignments cascade-clean on person removal
- Items can be added/removed via store actions; assignments cascade-delete on item removal
- Tax and tip can be set/cleared via store actions
- Store state round-trips through Zod validation without data loss
- Invalid persisted state falls back to clean defaults
- All 6 selector hooks return correct slices
- Zero test failures across entire test suite
</success_criteria>

<output>
After completion, create `.planning/phases/02-state-management-and-persistence/02-01-SUMMARY.md`
</output>
